using Pidgin;
using System.Collections.Generic;
using System;
using System.IO;
using System.Linq;
using System.Reflection;

namespace dnsl48.SGF
{
    using Lexer;
    using Model;

    /// <summary>
    /// The most basic parser of sintactically correct SGF data.
    /// Returns an empty collection if the syntax is incorrect
    /// </summary>
    /// <example><code>
    /// var parser = new dnsl48.SGF.NaiveParser();
    /// try {
    ///     var sgfCollection = parser.Parse("(;FF[4]GM[1]SZ[19]GN[Gametree 1: test tree])");
    /// } catch (dnsl48.SGF.NaiveParser.IParseError e) {
    ///     // incorrect SGF document
    /// } catch (Exception e) {
    ///     // runtime exception
    /// }
    /// </code></example>
    public class NaiveParser
    {
        /// <summary>
        /// Interface for all parsing errors happening in this parser
        /// </summary>
        public interface IParseError
        {
        }

        /// <summary>
        /// Base class for all parsing errors happening in this parser
        /// </summary>
        public class ParseError : IParseError
        {
        }

        /// <summary>
        /// Unregistered property has been generated by the lexer
        /// </summary>
        public class UnknownProperty : ParseError
        {
            /// <value>
            /// The property identity (name)
            /// </value>
            public string Identity { get; set; }

            /// <value>
            /// The values carried by the unknown property
            /// </value>
            public List<string> Values { get; set; }
        }

        /// <summary>
        /// The property constructor hasn't been implemented in a proper way
        /// so that property cannot be constructed at runtime
        /// </summary>
        public class UnconstructableProperty : ParseError
        {
            /// <value>
            /// The property identity (name)
            /// </value>
            public string Identity { get; set; }
        }

        /// <value>
        /// The list of all known property types
        /// </value>
        private Dictionary<string, Type> _propertyTypes = Meta.PropertyTypes;

        /// <value>
        /// The list of errors happened during parsing
        /// </value>
        private List<IParseError> _errors = new List<IParseError>();

        /// <summary>
        /// Parse a SGF document into a collection
        /// </summary>
        /// <param name="value">SGF document</param>
        /// <returns>Parsed collection of trees</returns>
        /// <exception cref="IParseError">A runtime error happened</exception>
        public Collection Parse(string value)
        {
            return _BuildResult(NaiveLexer.TreeParser.Many().Parse(value));
        }

        /// <summary>
        /// Parse a SGF document into a collection
        /// </summary>
        /// <param name="value">SGF document</param>
        /// <returns>Parsed collection of trees</returns>
        /// <exception cref="IParseError">A runtime error happened</exception>
        public Collection Parse(TextReader value)
        {
            return _BuildResult(NaiveLexer.TreeParser.Many().Parse(value));
        }

        /// <summary>
        /// Build SGF collection from the result with a list of lexemes.
        /// Otherwise, if the result is unsuccessful, returns an empty collection
        /// </summary>
        /// <param name="lexResult">List of NaiveLexer.Tree lexemes</param>
        /// <returns>Parsed collection of trees</returns>
        /// <exception cref="IParseError">A runtime error happened</exception>
        private Collection _BuildResult(Result<char, IEnumerable<NaiveLexer.Tree>> lexResult)
        {
            if (lexResult.Success)
            {
                return _BuildCollection(lexResult.Value);
            } else {
                return new Collection();
            }
        }

        /// <summary>
        /// Build SGF collection from the list of tree lexemes given
        /// </summary>
        /// <param name="trees">List of NaiveLexer.Tree lexemes</param>
        /// <returns>Parsed collection of trees</returns>
        /// <exception cref="IParseError">A runtime error happened</exception>
        private Collection _BuildCollection(IEnumerable<NaiveLexer.Tree> trees)
        {
            return new Collection(trees
                .Select(_BuildTree)
                .Where(a => a != null)
            );
        }

        /// <summary>
        /// Builds a Tree model from the Tree lexeme given
        /// </summary>
        /// <param name="tree">Tree lexeme</param>
        /// <returns>Tree model</returns>
        /// <exception cref="IParseError">A runtime error happened</exception>
        private Tree _BuildTree(NaiveLexer.Tree tree)
        {
            var nodes = tree.sequence.nodes
                .Skip(1) // lexer splits by ';', the first node is always empty
                .Select(_BuildNode)
                .Where(a => a != null);

            var children = tree.children
                .Select(_BuildTree)
                .Where(a => a != null);

            return new Tree(nodes, children);
        }

        /// <summary>
        /// Builds a Node model from the Node lexeme
        /// </summary>
        /// <param name="node">Node lexeme</param>
        /// <returns>Node model</returns>
        /// <exception cref="IParseError">A runtime error happened</exception>
        private Node _BuildNode(NaiveLexer.Node node)
        {
            var properties = node.properties
                .Select(_BuildProperty)
                .Where(a => a != null);

            return new Node(properties);
        }

        /// <summary>
        /// Builds a node property model from the lexeme given
        /// </summary>
        /// <param name="property">Property lexeme</param>
        /// <returns>Property model</returns>
        /// <exception cref="IParseError">A runtime error happened</exception>
        private IProperty _BuildProperty(NaiveLexer.Property property)
        {
            if (!this._propertyTypes.ContainsKey(property.label)) {
                var error = new UnknownProperty();
                error.Identity = property.label;
                error.Values = property.values;
                this._errors.Add(error);

                return new Model.Property.Misc.Unknown(property.label, property.values);
            }

            var propType = this._propertyTypes[property.label];
            var propCtor = propType.GetMethod("Parse", BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy);

            if (propCtor == null || !propCtor.IsStatic)
            {
                var error = new UnconstructableProperty();
                error.Identity = property.label;
                this._errors.Add(error);
                return null;
            }

            return (IProperty) propCtor.Invoke(null, new object[] { property.values });
        }
    }
}
